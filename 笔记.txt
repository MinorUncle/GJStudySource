1，oc的.h文件调用c++的.h时出错？
答：将该c++1.h文件在另一个c++2.h文件中引用，让后将c++1文件打包成静态库。最后oc.h引用c++1.h即可


下面是一些常见的异常编码:

    0x8badf00d: 读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的。  通常是应用花费太多时间而无法启动、终止或响应用系统事件。

    0xbad22222: 该编码表示 VoIP 应用因为过于频繁重启而被终止。
    0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。
    0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面

音频填充，需要对齐Frame单位的字节


字节对齐
１:数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节,则要从４的整数倍地址开始存储。

 

２:结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)

 

３:收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍.不足的要补齐.


浮点数存储：
1位符号位，8位指数偏移，23位精度。


oc与c语言的寻址区别
c/c++语言是按照属性在结构体内的偏移找到属性的地址的，如果A* a强制转换成(B*)a，则a中属性以a为基地址，加上属性在B结构体中的偏移计算属性地址。函数则是同一个类的所有函数地址相同,但是是在强制转换后的类中寻找同名函数。
oc中的属性则是直接绑定在实体属性地址列表中的，所以强制转换无效。函数地址同样也是同一个类公用一个函数体，但是也是直接在实体中存储的，所以强制转换也是无效的